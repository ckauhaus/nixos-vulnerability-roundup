use regex::Regex;
use snafu::Snafu;
use std::fmt;
use std::str;

#[derive(Debug, Snafu)]
pub enum Error {
    #[snafu(display("Failed to parse CVE identifier `{}'", id))]
    ParseCVE { id: String },
}

type Result<T, E = Error> = std::result::Result<T, E>;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Advisory {
    CVE { y: u16, n: u64 },
}

lazy_static! {
    static ref CVESPEC: Regex = Regex::new(r"^CVE-(\d{4})-(\d+)$").unwrap();
}

impl str::FromStr for Advisory {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let id = s.to_owned();
        match CVESPEC.captures(s) {
            Some(cap) => Ok(Advisory::CVE {
                y: cap[1]
                    .parse::<u16>()
                    .map_err(|_| Error::ParseCVE { id: id.clone() })?,
                n: cap[2]
                    .parse::<u64>()
                    .map_err(|_| Error::ParseCVE { id: id.clone() })?,
            }),
            None => Err(Error::ParseCVE { id }),
        }
    }
}

impl fmt::Display for Advisory {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        match self {
            Advisory::CVE { y, n } => write!(f, "CVE-{}-{}", y, n),
        }
    }
}

// === Tests ===

#[cfg(test)]
mod test {
    use super::*;
    use assert_matches::assert_matches;

    #[test]
    fn fmt_cve() {
        let cve = Advisory::CVE {
            y: 2019,
            n: 1003544,
        };
        assert_eq!(cve.to_string(), "CVE-2019-1003544");
    }

    #[test]
    fn parse_cve() {
        assert_eq!(
            "CVE-2019-20484"
                .parse::<Advisory>()
                .expect("no parse error"),
            Advisory::CVE { y: 2019, n: 20484 }
        );
        assert_matches!("CVE-20".parse::<Advisory>(), Err(Error::ParseCVE { .. }));
    }
}
