use failure::Fallible;
use scan::{Branches, VulnixRes};
use std::collections::HashMap;
use std::hash::Hash;
use std::io::{self, Write};

pub type Packages<'a> = HashMap<&'a str, Affected<'a>>;

#[derive(Debug, Clone, Default, PartialEq)]
pub struct Affected<'a> {
    pname: &'a str,
    version: &'a str,
    advisories: Vec<&'a str>,
    // Affected flag by branch: for each advisory, if a branch is affected, the bit according to
    // the branch index is set
    branchmap: Vec<u64>,
}

impl<'a> Affected<'a> {
    fn new(pname: &'a str, version: &'a str) -> Self {
        Self {
            pname,
            version,
            ..Default::default()
        }
    }

    /// Writes out an issue in markdown format for a single package
    pub fn write_ticket(
        &self,
        file: &mut dyn Write,
        iteration: u32,
        branches: &Branches,
    ) -> Result<(), io::Error> {
        let num = self.advisories.len();
        let adv = if num == 1 { "advisory" } else { "advisories" };
        writeln!(file, "\
# Vulnerability roundup {iteration}: {pname}-{version}: {num} {adv}\n\
\n\
[search](https://search.nix.gsc.io/?q={pname}&i=fosho&repos=nixos-nixpkgs), \
[files](https://github.com/NixOS/nixpkgs/search?utf8=%E2%9C%93&q={pname}+in%3Apath&type=Code)\n\
        ", iteration=iteration, num=num, adv=adv, pname=self.pname, version=self.version)?;
        let mut relevant_branches = 0b0;
        for (i, adv) in self.advisories.iter().enumerate() {
            let applicable = branches.decode(self.branchmap[i]).join(", ");
            writeln!(
                file,
                "* [ ] [{adv}](https://nvd.nist.gov/vuln/detail/{adv}) ({applicable})",
                adv = adv,
                applicable = applicable
            )?;
            relevant_branches |= self.branchmap[i];
        }
        writeln!(
            file,
            "\nScanned versions: {}. May contain false positives.",
            branches
                .iter_mask(relevant_branches)
                .map(|b| format!("{}: {}", b.name, &b.rev[..11]))
                .collect::<Vec<String>>()
                .join("; ")
        )
    }
}

/// Consolidates per-branch scan results into a per-package overview
pub fn transform<S>(scan_by_branch: &[Vec<VulnixRes<S>>]) -> Fallible<Packages>
where
    S: AsRef<str> + Hash + Eq,
{
    let mut pkgs = Packages::new();
    for (nbranch, scan) in scan_by_branch.into_iter().enumerate() {
        for res in scan {
            let affected = pkgs
                .entry(res.name.as_ref())
                .or_insert_with(|| Affected::new(res.pname.as_ref(), res.version.as_ref()));
            for adv in &res.affected_by {
                match affected.advisories.iter().position(|&s| s == adv.as_ref()) {
                    Some(pos) => affected.branchmap[pos] |= 1 << nbranch,
                    None => {
                        affected.advisories.push(adv.as_ref());
                        affected.branchmap.push(1 << nbranch);
                    }
                }
            }
        }
    }
    Ok(pkgs)
}

// === Tests ===

#[cfg(test)]
mod tests {
    use super::*;
    use tests::create_branches;

    /// Helper to construct an `Affected` value easily
    fn aff<'a>(
        pname: &'a str,
        version: &'a str,
        advisories: &[&'a str],
        branchmap: &[u64],
    ) -> Affected<'a> {
        Affected {
            pname,
            version,
            advisories: advisories.to_vec(),
            branchmap: branchmap.to_vec(),
        }
    }

    #[test]
    fn decode_scan_single_branch() {
        let scan = vec![vec![
            VulnixRes {
                name: "ncurses-6.1",
                pname: "ncurses",
                version: "6.1",
                affected_by: vec!["CVE-2018-10754"],
            },
            VulnixRes {
                name: "libtiff-4.0.9",
                pname: "libtiff",
                version: "4.0.9",
                affected_by: vec!["CVE-2018-17000", "CVE-2018-17100", "CVE-2018-17101"],
            },
        ]];
        assert_eq!(
            transform(&scan).unwrap(),
            [
                (
                    "libtiff-4.0.9",
                    aff(
                        "libtiff",
                        "4.0.9",
                        &["CVE-2018-17000", "CVE-2018-17100", "CVE-2018-17101"],
                        &[0b1, 0b1, 0b1]
                    )
                ),
                (
                    "ncurses-6.1",
                    aff("ncurses", "6.1", &["CVE-2018-10754"], &[0b1])
                ),
            ]
            .iter()
            .cloned()
            .collect()
        )
    }

    #[test]
    fn decode_scan_multiple_branches() {
        let scan = vec![
            vec![VulnixRes {
                name: "libtiff-4.0.9",
                pname: "libtiff",
                version: "4.0.9",
                affected_by: vec!["CVE-2018-17100", "CVE-2018-17101"],
            }],
            vec![VulnixRes {
                name: "libtiff-4.0.9",
                pname: "libtiff",
                version: "4.0.9",
                affected_by: vec!["CVE-2018-17101"],
            }],
        ];
        assert_eq!(
            transform(&scan).unwrap(),
            [(
                "libtiff-4.0.9",
                aff(
                    "libtiff",
                    "4.0.9",
                    &["CVE-2018-17100", "CVE-2018-17101"],
                    &[0b01, 0b11]
                )
            )]
            .iter()
            .cloned()
            .collect()
        )
    }

    fn ticket(affected: &Affected, branches: &Branches) -> String {
        let mut buf = Vec::new();
        affected.write_ticket(&mut buf, 1, branches).ok();
        String::from_utf8(buf).unwrap()
    }

    #[test]
    fn rendered_ticket() -> Fallible<()> {
        let libtiff = aff(
            "libtiff",
            "4.0.9",
            &["CVE-2018-17100", "CVE-2018-17101"],
            &[0b01, 0b11],
        );
        let branches = &create_branches(&[
            "nixos-18.09=5d4a1a3897e2d674522bcb3aa0026c9e32d8fd7c",
            "nixos-unstable=80738ed9dc0ce48d7796baed5364eef8072c794d",
        ])?;
        assert_eq!(ticket(&libtiff, branches), "\
# Vulnerability roundup 1: libtiff-4.0.9: 2 advisories\n\
\n\
[search](https://search.nix.gsc.io/?q=libtiff&i=fosho&repos=nixos-nixpkgs), \
[files](https://github.com/NixOS/nixpkgs/search?utf8=%E2%9C%93&q=libtiff+in%3Apath&type=Code)\n\
\n\
* [ ] [CVE-2018-17100](https://nvd.nist.gov/vuln/detail/CVE-2018-17100) (nixos-18.09)\n\
* [ ] [CVE-2018-17101](https://nvd.nist.gov/vuln/detail/CVE-2018-17101) (nixos-18.09, nixos-unstable)\n\
\n\
Scanned versions: nixos-18.09: 5d4a1a3897e; nixos-unstable: 80738ed9dc0. \
May contain false positives.\n\
        ");
        Ok(())
    }

    #[test]
    fn print_only_relevant_branches() -> Fallible<()> {
        let libtiff = aff("libtiff", "4.0.9", &["CVE-2018-17100"], &[0b01]);
        let branches = &create_branches(&[
            "nixos-18.09=5d4a1a3897e2d674522bcb3aa0026c9e32d8fd7c",
            "nixos-unstable=80738ed9dc0ce48d7796baed5364eef8072c794d",
        ])?;
        let ticket = ticket(&libtiff, branches);
        assert!(
            ticket.contains("versions: nixos-18.09: 5d4a1a3897e. May"),
            format!("branch summary not correct\n{}", ticket)
        );
        Ok(())
    }
}
