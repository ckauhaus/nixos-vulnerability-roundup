use crate::advisory::Advisory;
use crate::package::Package;
use crate::scan::{Branch, ScanByBranch};
use std::collections::{HashMap, HashSet};
use std::fmt::{self, Write};
use std::path::PathBuf;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Ticket {
    iteration: u32,
    pkg: Package,
    affected: HashMap<Advisory, Vec<Branch>>,
}

impl Ticket {
    /// Creates a new Ticket with empty 'affected' list.
    pub fn new(iteration: u32, pkg: Package) -> Self {
        Self {
            iteration,
            pkg,
            affected: HashMap::new(),
        }
    }

    /// Local file name (excluding directory)
    pub fn file_name(&self) -> PathBuf {
        PathBuf::from(format!("ticket.{}.md", self.pkg.name))
    }

    /// Package name + version
    pub fn name(&self) -> &str {
        &self.pkg.name
    }

    /// Package name without version
    pub fn pname(&self) -> &str {
        &self.pkg.pname()
    }

    pub fn summary(&self) -> String {
        let num = self.affected.len();
        let advisory = if num == 1 { "advisory" } else { "advisories" };
        format!(
            "Vulnerability roundup {}: {}: {} {}",
            self.iteration, self.pkg.name, num, advisory
        )
    }

    pub fn body(&self) -> String {
        let mut res = String::with_capacity(1000);
        writeln!(&mut res, "\
[search](https://search.nix.gsc.io/?q={pname}&i=fosho&repos=NixOS-nixpkgs), \
[files](https://github.com/NixOS/nixpkgs/search?utf8=%E2%9C%93&q={pname}+in%3Apath&type=Code)\n\
", pname=self.pname())
        .ok();
        let mut aff: Vec<(&Advisory, &Vec<Branch>)> = self.affected.iter().collect();
        aff.sort();
        for (advisory, branches) in aff {
            let b: Vec<&str> = branches.iter().map(|b| b.name.as_str()).collect();
            writeln!(
                &mut res,
                "* [ ] [{adv}](https://nvd.nist.gov/vuln/detail/{adv}) ({b})",
                adv = advisory,
                b = b.join(", ")
            )
            .ok();
        }
        let relevant: HashSet<&Branch> = self.affected.values().flat_map(|b| b.iter()).collect();
        let relevant: Vec<String> = relevant
            .into_iter()
            .map(|b| format!("{}: {}", b.name.as_str(), &b.rev.as_str()[..9]))
            .collect();
        writeln!(
            &mut res,
            "\nScanned versions: {}. May contain false positives.",
            relevant.join("; ")
        )
        .ok();
        res
    }
}

impl fmt::Display for Ticket {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "{}\n\n{}", self.summary(), self.body())
    }
}

/// One ticket per package, containing scan results for all branches
pub fn ticket_list(iteration: u32, mut scan_by_branch: ScanByBranch) -> Vec<Ticket> {
    // Step 1: for each pkgs, list all pairs (advisory, branch) in random order
    let mut acc: HashMap<Package, Vec<(Advisory, Branch)>> = HashMap::new();
    for (branch, scan_results) in scan_by_branch.drain() {
        for res in scan_results {
            let e = acc.entry(res.pkg).or_insert_with(Vec::new);
            e.extend(res.affected_by.into_iter().map(|adv| (adv, branch.clone())));
        }
    }
    // Step 2: consolidate branches
    let mut tickets: Vec<Ticket> = acc
        .into_iter()
        .map(|(pkg, aff)| {
            let mut t = Ticket::new(iteration, pkg);
            for (advisory, branch) in aff {
                t.affected.entry(advisory).or_default().push(branch);
            }
            t
        })
        .collect();
    tickets.sort_by(|a, b| a.pkg.cmp(&b.pkg));
    tickets
}

// === Tests ===

#[cfg(test)]
mod test {
    use super::*;
    use crate::tests::create_branches;

    /// Helper to construct an `Affected` value easily
    fn aff<'a>(
        pname: &'a str,
        version: &'a str,
        advisories: &[&'a str],
        branchmap: &[u32],
    ) -> Affected<'a> {
        Affected {
            pname,
            version,
            map: advisories
                .iter()
                .zip(branchmap.iter())
                .map(|(a, &bm)| VulnByBranch::from_branchmap(a.parse().unwrap(), bm))
                .collect(),
        }
    }

    #[test]
    fn decode_scan_single_branch() {
        let scan = vec![vec![
            VulnixRes {
                name: "ncurses-6.1",
                pname: "ncurses",
                version: "6.1",
                affected_by: vec!["CVE-2018-10754"],
            },
            VulnixRes {
                name: "libtiff-4.0.9",
                pname: "libtiff",
                version: "4.0.9",
                affected_by: vec!["CVE-2018-17000", "CVE-2018-17100", "CVE-2018-17101"],
            },
        ]];
        assert_eq!(
            transform(&scan).unwrap(),
            [
                (
                    "libtiff-4.0.9",
                    aff(
                        "libtiff",
                        "4.0.9",
                        &["CVE-2018-17000", "CVE-2018-17100", "CVE-2018-17101"],
                        &[0b1, 0b1, 0b1]
                    )
                ),
                (
                    "ncurses-6.1",
                    aff("ncurses", "6.1", &["CVE-2018-10754"], &[0b1])
                ),
            ]
            .iter()
            .cloned()
            .collect()
        )
    }

    #[test]
    fn decode_scan_multiple_branches() {
        let scan = vec![
            vec![VulnixRes {
                name: "libtiff-4.0.9",
                pname: "libtiff",
                version: "4.0.9",
                affected_by: vec!["CVE-2018-17100", "CVE-2018-17101"],
            }],
            vec![VulnixRes {
                name: "libtiff-4.0.9",
                pname: "libtiff",
                version: "4.0.9",
                affected_by: vec!["CVE-2018-17101"],
            }],
        ];
        assert_eq!(
            transform(&scan).unwrap(),
            [(
                "libtiff-4.0.9",
                aff(
                    "libtiff",
                    "4.0.9",
                    &["CVE-2018-17100", "CVE-2018-17101"],
                    &[0b01, 0b11]
                )
            )]
            .iter()
            .cloned()
            .collect()
        )
    }

    fn ticket(affected: &Affected, branches: &Branches) -> String {
        let mut buf = Vec::new();
        affected.write_ticket(&mut buf, 1, branches).ok();
        String::from_utf8(buf).unwrap()
    }

    #[test]
    fn rendered_ticket() -> Fallible<()> {
        let libtiff = aff(
            "libtiff",
            "4.0.9",
            &["CVE-2018-17100", "CVE-2018-17101"],
            &[0b01, 0b11],
        );
        let branches = &create_branches(&[
            "nixos-18.09=5d4a1a3897e2d674522bcb3aa0026c9e32d8fd7c",
            "nixos-unstable=80738ed9dc0ce48d7796baed5364eef8072c794d",
        ])?;
        assert_eq!(ticket(&libtiff, branches), "\
Vulnerability roundup 1: libtiff-4.0.9: 2 advisories\n\
\n\
[search](https://search.nix.gsc.io/?q=libtiff&i=fosho&repos=nixos-nixpkgs), \
[files](https://github.com/NixOS/nixpkgs/search?utf8=%E2%9C%93&q=libtiff+in%3Apath&type=Code)\n\
\n\
* [ ] [CVE-2018-17100](https://nvd.nist.gov/vuln/detail/CVE-2018-17100) (nixos-18.09)\n\
* [ ] [CVE-2018-17101](https://nvd.nist.gov/vuln/detail/CVE-2018-17101) (nixos-18.09, nixos-unstable)\n\
\n\
Scanned versions: nixos-18.09: 5d4a1a3897e; nixos-unstable: 80738ed9dc0. \
May contain false positives.\n\
        ");
        Ok(())
    }

    #[test]
    fn print_only_relevant_branches() -> Fallible<()> {
        let libtiff = aff("libtiff", "4.0.9", &["CVE-2018-17100"], &[0b01]);
        let branches = &create_branches(&[
            "nixos-18.09=5d4a1a3897e2d674522bcb3aa0026c9e32d8fd7c",
            "nixos-unstable=80738ed9dc0ce48d7796baed5364eef8072c794d",
        ])?;
        let ticket = ticket(&libtiff, branches);
        assert!(
            ticket.contains("versions: nixos-18.09: 5d4a1a3897e. May"),
            format!("branch summary not correct:\n{}", ticket)
        );
        Ok(())
    }

    fn mk_vuln(branchmap: u32) -> VulnByBranch {
        VulnByBranch::from_branchmap(Advisory::CVE { y: 0, n: 0 }, branchmap)
    }

    #[test]
    fn decode_names() {
        let b = create_branches(&["a", "b", "c"]).unwrap();
        assert_eq!(mk_vuln(0b000).decode(&b), &[] as &[&str]);
        assert_eq!(mk_vuln(0b001).decode(&b), &["a"]);
        assert_eq!(mk_vuln(0b110).decode(&b), &["b", "c"]);
    }
}
