use branches::Branches;
use failure::{Fallible, ResultExt};
use std::collections::HashMap;
use std::fs::File;
use std::io::Write;
use std::path::Path;

#[derive(Debug, Clone, Default, Deserialize)]
struct VulnixRes {
    name: String,
    pname: String,
    version: String,
    affected_by: Vec<String>,
}

#[derive(Debug, Clone, Default, PartialEq, Serialize)]
pub struct Affected {
    pname: String,
    version: String,
    advisories: Vec<String>,
    /// Affected by branch: for each advisory, if a branch is affected, the bit according to the
    /// branch index is set
    branchmap: Vec<u64>,
}

impl Affected {
    fn new(pname: String, version: String) -> Self {
        Self {
            pname,
            version,
            ..Default::default()
        }
    }

    pub fn write_ticket(
        &self,
        file: &mut dyn Write,
        name: &str,
        iteration: u32,
        branches: &Branches,
    ) -> Fallible<()> {
        let num = self.advisories.len();
        let adv = if num == 1 { "advisory" } else { "advisories" };
        writeln!(file, "\
# Vulnerability roundup {iteration}: {name}: {num} {adv}\n\
\n\
[search](https://search.nix.gsc.io/?q={pname}&i=fosho&repos=nixos-nixpkgs), \
[files](https://github.com/NixOS/nixpkgs/search?utf8=%E2%9C%93&q={pname}+in%3Apath&type=Code)\n\
        ", iteration=iteration, name=name, num=num, adv=adv, pname=self.pname)?;
        for (i, adv) in self.advisories.iter().enumerate() {
            let applicable = branches.decode(self.branchmap[i]).join(", ");
            write!(
                file,
                "\
                 * [ ] [{adv}](https://nvd.nist.gov/vuln/detail/{adv}) ({applicable})\n\
                 ",
                adv = adv,
                applicable = applicable
            )?;
        }
        Ok(())
    }
}

pub type Packages = HashMap<String, Affected>;

fn vulnix2pkgs(scan_by_branch: Vec<Vec<VulnixRes>>) -> Packages {
    let mut pkgs = HashMap::new();
    for (nbranch, scan) in scan_by_branch.into_iter().enumerate() {
        for res in scan {
            let affected = pkgs
                .entry(res.name)
                .or_insert(Affected::new(res.pname, res.version));
            for adv in res.affected_by {
                match affected.advisories.iter().position(|s| s == &adv) {
                    Some(pos) => affected.branchmap[pos] |= 1 << nbranch,
                    None => {
                        affected.advisories.push(adv);
                        affected.branchmap.push(1 << nbranch);
                    }
                }
            }
        }
    }
    pkgs
}

pub fn transform(dir: &Path, branches: &Branches) -> Fallible<Packages> {
    let vulnix_res = branches
        .iter()
        .map(|b| {
            let fname = dir.join(format!("vulnix.{}.json", b.name));
            File::open(&fname)
                .with_context(|_| format!("Cannot open file '{}'", fname.display()))
                .and_then(|f| {
                    serde_json::from_reader(f).with_context(|_| {
                        format!("Failed to parse JSON file '{}'", fname.display())
                    })
                })
        }).collect::<Result<Vec<_>, _>>()?;
    Ok(vulnix2pkgs(vulnix_res))
}

// === Tests ===

#[cfg(test)]
mod tests {
    use super::*;
    use tests::create_branches;

    /// Helper to construct an `Affected` value quickly
    fn aff(pname: &str, version: &str, advisories: &[&str], branchmap: &[u64]) -> Affected {
        Affected {
            pname: pname.into(),
            version: version.into(),
            advisories: advisories.into_iter().map(|&e| e.to_owned()).collect(),
            branchmap: branchmap.to_vec(),
        }
    }

    #[test]
    fn decode_scan_single_branch() {
        let scan = vec![vec![
            VulnixRes {
                name: "ncurses-6.1".into(),
                pname: "ncurses".into(),
                version: "6.1".into(),
                affected_by: vec!["CVE-2018-10754".into()],
            },
            VulnixRes {
                name: "libtiff-4.0.9".into(),
                pname: "libtiff".into(),
                version: "4.0.9".into(),
                affected_by: vec!["CVE-2018-17000", "CVE-2018-17100", "CVE-2018-17101"]
                    .into_iter()
                    .map(Into::into)
                    .collect(),
            },
        ]];
        assert_eq!(
            vulnix2pkgs(scan),
            [
                (
                    "libtiff-4.0.9".into(),
                    aff(
                        "libtiff",
                        "4.0.9",
                        &["CVE-2018-17000", "CVE-2018-17100", "CVE-2018-17101"],
                        &[0b1, 0b1, 0b1]
                    )
                ),
                (
                    "ncurses-6.1".into(),
                    aff("ncurses", "6.1", &["CVE-2018-10754"], &[0b1])
                ),
            ]
                .iter()
                .cloned()
                .collect()
        )
    }

    #[test]
    fn decode_json() {
        let branches = create_branches(&["nixos-18.03", "nixos-18.09", "nixos-unstable"]).unwrap();
        let reldir = Path::new(env!("CARGO_MANIFEST_DIR")).join("fixtures/iterations/1");
        let pkgs = transform(&reldir, &branches).unwrap();
        assert_eq!(pkgs.len(), 4);
        assert_eq!(
            pkgs["binutils-2.30"],
            aff(
                "binutils",
                "2.30",
                &["CVE-2018-7569", "CVE-2018-7568"],
                &[0b110, 0b100]
            )
        );
        assert_eq!(
            pkgs["openjpeg-2.3.0"],
            aff("openjpeg", "2.3.0", &["CVE-2018-16376"], &[0b011])
        );
        assert_eq!(
            pkgs["libtasn1-4.13"],
            aff(
                "libtasn1",
                "4.13",
                &["CVE-2018-1000654", "CVE-2018-7570"],
                &[0b111, 0b001]
            )
        );
        assert_eq!(
            pkgs["ncurses-6.1"],
            aff("ncurses", "6.1", &["CVE-2018-10754"], &[0b110])
        );
    }
}
