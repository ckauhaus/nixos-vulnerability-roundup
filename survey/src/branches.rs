use regex::Regex;
use std::ops::Deref;
use std::path::PathBuf;
use std::str::FromStr;

#[derive(Debug, Fail)]
pub enum BranchError {
    #[fail(
        display = "Failed to recognize branch specification '{}'",
        _0
    )]
    InvalidSpec(String),
    #[fail(display = "Branch name '{}' is not unique", _0)]
    Duplicate(String),
}

#[derive(Debug, Clone, Default)]
pub struct Branches {
    specs: Vec<BranchSpec>,
    repo: Option<PathBuf>, // XXX use git specific data type?
}

impl Branches {
    pub fn init(specs: &[BranchSpec]) -> Result<Self, BranchError> {
        let b = Self {
            specs: specs.to_owned(),
            ..Default::default()
        };
        for (idx, elem) in specs.iter().enumerate() {
            if specs.iter().skip(idx + 1).any(|s| s.name == elem.name) {
                return Err(BranchError::Duplicate(elem.name.clone()));
            }
        }
        Ok(b)
    }

    // pub fn from_git_repo XXX

    pub fn decode(&self, branchmap: u64) -> Vec<&str> {
        let mut names = Vec::with_capacity(self.specs.len());
        for (idx, elem) in self.iter().enumerate() {
            if branchmap & (1 << idx) > 0 {
                names.push(elem.name.as_ref())
            }
        }
        names
    }
}

impl Deref for Branches {
    type Target = [BranchSpec];

    fn deref(&self) -> &Self::Target {
        &self.specs
    }
}

#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct BranchSpec {
    pub name: String,
    pub rev: String,
}

impl BranchSpec {
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_owned(),
            rev: name.to_owned(),
        }
    }
}

lazy_static! {
    static ref BRANCHSPEC: Regex = Regex::new(r"^([^/=[:space:]]+)(=(\S+))?$").unwrap();
}

impl FromStr for BranchSpec {
    type Err = BranchError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match BRANCHSPEC.captures(s) {
            Some(cap) => {
                let name = &cap[1];
                match cap.get(3) {
                    Some(rev) => Ok(BranchSpec {
                        name: name.into(),
                        rev: rev.as_str().into(),
                    }),
                    None => Ok(BranchSpec::new(name)),
                }
            }
            None => Err(BranchError::InvalidSpec(s.to_owned())),
        }
    }
}

// === Tests ===

#[cfg(test)]
mod tests {
    use super::*;
    use tests::create_branches;

    #[test]
    fn correct_branchspecs() {
        assert_eq!(
            BranchSpec::from_str("nixos-18.09").unwrap(),
            BranchSpec {
                name: "nixos-18.09".into(),
                rev: "nixos-18.09".into()
            }
        );
        assert_eq!(
            BranchSpec::from_str("nixos-18.09=55f4cd48").unwrap(),
            BranchSpec {
                name: "nixos-18.09".into(),
                rev: "55f4cd48".into()
            }
        );
        assert_eq!(
            BranchSpec::from_str("nixos-18.09=origin/release-18.09").unwrap(),
            BranchSpec {
                name: "nixos-18.09".into(),
                rev: "origin/release-18.09".into()
            }
        );
    }

    #[test]
    fn branchspec_invalid_chars() {
        assert!(BranchSpec::from_str("nixos 18.09").is_err());
        assert!(BranchSpec::from_str("origin/nixos-18.09").is_err());
    }

    #[test]
    fn branchspec_empty() {
        assert!(BranchSpec::from_str("nixos=").is_err());
        assert!(BranchSpec::from_str("=abcdefg").is_err());
    }

    #[test]
    fn no_duplicate_branch_names() {
        assert!(create_branches(&["a", "b"]).is_ok());
        assert!(create_branches(&["a", "b", "a"]).is_err());
    }

    #[test]
    fn decode_names() {
        let b = create_branches(&["a", "b", "c"]).unwrap();
        assert_eq!(b.decode(0b000), &[] as &[&str]);
        assert_eq!(b.decode(0b001), &["a"]);
        assert_eq!(b.decode(0b110), &["b", "c"]);
    }
}
