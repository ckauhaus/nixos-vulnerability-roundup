use regex::Regex;
use snafu::Snafu;
use std::convert::TryFrom;
use std::fmt;
use std::str::FromStr;

#[derive(Debug, Snafu)]
pub enum Error {
    #[snafu(display("Failed to find version in derivation name '{}'", name))]
    Version { name: String },
}

#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(try_from = "String")]
pub struct Package {
    pub name: String,
    v_idx: usize,
}

impl Package {
    #[cfg(test)]
    fn new<S: AsRef<String>>(pname: S, version: S) -> Self {
        let pname = pname.as_ref();
        Self {
            name: pname.to_string() + "-" + version.as_ref(),
            v_idx: pname.len() + 1,
        }
    }

    pub fn pname(&self) -> &str {
        &self.name[..self.v_idx - 1]
    }

    #[cfg(test)]
    fn version(&self) -> &str {
        &self.name[self.v_idx..]
    }
}

impl fmt::Display for Package {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        write!(fmt, "{}", self.name)
    }
}

lazy_static! {
    /// See parseDrvName in https://nixos.org/nix/manual/#ssec-builtins
    static ref VERSION_SPLIT: Regex = Regex::new(r"-[0-9]").unwrap();
}

impl FromStr for Package {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Some(m) = VERSION_SPLIT.find(s) {
            Ok(Self {
                name: s.to_owned(),
                v_idx: m.start() + 1,
            })
        } else {
            (Version { name: s }).fail()
        }
    }
}

impl TryFrom<String> for Package {
    type Error = <Self as FromStr>::Err;

    fn try_from(s: String) -> Result<Self, Self::Error> {
        FromStr::from_str(&s)
    }
}

// === Tests ===

#[cfg(test)]
mod test {
    use super::*;

    // XXX tests
}
