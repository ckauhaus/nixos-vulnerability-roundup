/// Interface to issue trackers.
///
/// Implements currently only GitHub issues.
use crate::ticket::Ticket;
use clap::{crate_name, crate_version};
use futures::future::*;
use futures::Stream;
use hubcaps::comments::CommentOptions;
use hubcaps::issues::IssueOptions;
use hubcaps::Credentials;
use hyper::client::HttpConnector;
use hyper_tls::HttpsConnector;
use snafu::{IntoError, Snafu};
use tokio::runtime::Runtime;

type Github = hubcaps::Github<HttpsConnector<HttpConnector>>;

#[derive(Debug, Snafu)]
pub enum Error {
    #[snafu(display("..."))]
    Connect { msg: String },
    #[snafu(display("GITHUB_TOKEN not found in either environment or .env file"))]
    Token,
    #[snafu(display("..."))]
    Issue { msg: String },
    #[snafu(display("Github error while creating issue"))]
    Creating { source: hubcaps::Error },
    #[snafu(display("Github error while searching for related issues"))]
    Searching { source: hubcaps::Error },
    #[snafu(display("Github error while commenting on related issues"))]
    Commenting { source: hubcaps::Error },
}

type Result<T, E = Error> = std::result::Result<T, E>;

#[derive(Debug, Clone)]
pub struct Tracker {
    conn: Github,
    owner: String,
    repo: String,
}

impl Tracker {
    pub fn connect_github(token: String, owner: &str, repo: &str) -> Self {
        Self {
            conn: Github::new(
                concat!(crate_name!(), "/", crate_version!()),
                Credentials::Token(token),
            ),
            owner: owner.to_owned(),
            repo: repo.to_owned(),
        }
    }

    pub fn create_issue(&self, tkt: &Ticket) -> Result<u64> {
        let issues = self.conn.repo(&self.owner, &self.repo).issues();
        let create = issues
            .create(&IssueOptions {
                title: tkt.summary(),
                body: Some(tkt.body()),
                assignee: None,
                milestone: None,
                labels: vec!["1.severity: security".to_owned()],
            })
            .map_err(|e| Creating {}.into_error(e));

        let related_q = format!("\
repo:{}/{} is:open label:\"1.severity: security\"  in:title \"Vulnerability roundup \" \" {}: \"",
self.owner, self.repo, tkt.name());
        let related = self
            .conn
            .search()
            .issues()
            .iter(&related_q, &Default::default())
            .map(|rel| format!("#{}", rel.number))
            .collect()
            .map_err(|e| Searching {}.into_error(e));

        let mut rt = Runtime::new().unwrap();
        rt.block_on(create.join(related).and_then(move |(iss, related)| {
            if !related.is_empty() {
                let seealso = format!("See also: {}", related.join(", "));
                Either::A(
                    issues
                        .get(iss.number)
                        .comments()
                        .create(&CommentOptions { body: seealso })
                        .and_then(move |_| ok(iss.number))
                        .map_err(|e| Commenting {}.into_error(e)),
                )
            } else {
                Either::B(ok(iss.number))
            }
        }))
    }
}
