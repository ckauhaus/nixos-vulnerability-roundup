extern crate regex;
extern crate structopt;
extern crate structopt_derive;
#[macro_use]
extern crate failure;
#[macro_use]
extern crate failure_derive;
#[macro_use]
extern crate lazy_static;
extern crate serde;
extern crate serde_json;
#[macro_use]
extern crate serde_derive;
extern crate colored;
extern crate subprocess;
#[cfg(test)]
extern crate tempdir;

mod scan;
#[cfg(test)]
mod tests;
mod ticket;

use colored::*;
use failure::Fallible;
use scan::{Branch, Branches};
use std::fs::File;
use std::path::PathBuf;
use std::process;
use structopt::StructOpt;

#[derive(Debug, Clone, StructOpt, Default)]
pub struct Opt {
    /// Output directory for vulnix JSON outputs and tickets (adds subdir by iteration)
    #[structopt(
        short = "o",
        long = "outdir",
        value_name = "DIR",
        default_value = "./iterations",
        parse(from_os_str)
    )]
    reldir: PathBuf,
    /// Directory for updated whitelists (expected to be pushed to `whitelist_url` eventually)
    #[structopt(
        short = "w",
        long = "whitelists",
        value_name = "DIR",
        default_value = "./whitelists",
        parse(from_os_str)
    )]
    whitelist_dir: PathBuf,
    /// Base URL to load current whitelists from (release name will be appended)
    #[structopt(
        short = "W",
        long = "whitelist-url",
        value_name = "URL",
        default_value = "https://raw.githubusercontent.com/ckauhaus/nixos-vulnerability-roundup/\
                         master/whitelists",
    )]
    whitelist_url: String,
    /// Path to `vulnix` executable
    #[structopt(
        short = "v",
        long = "vulnix",
        value_name = "PATH",
        default_value = "vulnix",
        parse(from_os_str)
    )]
    vulnix: PathBuf,
    /// Path to `nixpkgs` checkout
    #[structopt(
        short = "n",
        long = "nixpkgs",
        value_name = "PATH",
        default_value = "../nixpkgs-channels",
        parse(from_os_str)
    )]
    nixpkgs: PathBuf,
    /// Don't run vulnix (expects vulnix JSON output already present in release dir)
    #[structopt(short = "R", long = "no-run")]
    no_run: bool,
    /// Nth survey iteration
    #[structopt(value_name = "N")]
    iteration: u32,
    /// List of nixpkgs branches to scan in the format BRANCH=COMMITID or just BRANCH (uses
    /// current branch head) [examples: "nixos-18.09" or "nixos-unstable=55f4cd48"]
    #[structopt(value_name = "BRANCHES", raw(required = "true"))]
    branches: Vec<Branch>,
}

impl Opt {
    /// Constructs per-iteration directory from reldir and iteration number
    pub fn iterdir(&self) -> PathBuf {
        self.reldir.join(self.iteration.to_string())
    }
}

fn run() -> Fallible<()> {
    let opt = Opt::from_args();
    let branches = Branches::with_repo(&opt.branches, &opt.nixpkgs)?;
    ensure!(branches.len() < 64, "Too many branches specified");
    let dir = opt.iterdir();
    let scan_res = if opt.no_run {
        branches.load(&dir)?
    } else {
        branches.scan(&opt)?
    };
    println!("{}", "* Creating tickets...".green());
    for (name, affected) in ticket::transform(&scan_res)?.iter() {
        let outfile = dir.join(format!("ticket.{}.md", name));
        println!("{} {}", format!("{}:", name).yellow(), outfile.display());
        let mut f = File::create(outfile)?;
        affected.write_ticket(&mut f, name, opt.iteration, &branches)?;
    }
    Ok(())
}

fn main() {
    if let Err(e) = run() {
        eprintln!("Error: {}", e.to_string().red().bold());
        for cause in e.iter_causes() {
            eprintln!("Cause: {}", cause);
        }
        process::exit(1);
    }
}
