#[macro_use]
extern crate failure;
extern crate regex;
extern crate structopt;
extern crate structopt_derive;
#[macro_use]
extern crate failure_derive;
#[macro_use]
extern crate lazy_static;
extern crate serde;
extern crate serde_json;
#[macro_use]
extern crate serde_derive;

mod branches;
#[cfg(test)]
mod tests;
mod ticket;

use branches::{BranchSpec, Branches};
use failure::Fallible;
use std::fs::File;
use std::path::PathBuf;
use std::process;
use structopt::StructOpt;
use ticket::transform;

#[derive(Debug, Clone, StructOpt)]
struct Opt {
    /// Output directory for vulnix JSON outputs and tickets (adds subdir by iteration)
    #[structopt(
        short = "o",
        long = "out-dir",
        value_name = "DIR",
        default_value = "./iterations",
        parse(from_os_str)
    )]
    reldir: PathBuf,
    /// Path to `vulnix` executable
    #[structopt(
        short = "v",
        long = "vulnix",
        value_name = "PATH",
        default_value = "vulnix",
        parse(from_os_str)
    )]
    vulnix: PathBuf,
    /// Path to `nixpkgs` checkout
    #[structopt(
        short = "n",
        long = "nixpkgs",
        value_name = "PATH",
        default_value = "../nixpkgs-channels",
        parse(from_os_str)
    )]
    nixpkgs: PathBuf,
    /// Don't run vulnix (expects vulnix JSON output already present in release dir)
    #[structopt(short = "R", long = "no-run")]
    no_run: bool,
    /// Nth survey iteration
    #[structopt(value_name = "N")]
    iteration: u32,
    /// List of nixpkgs branches to scan in the format BRANCH=COMMITID or just BRANCH (uses
    /// current branch head) [examples: "nixos-18.09" or "nixos-18.09=55f4cd48"]
    #[structopt(value_name = "BRANCHES", raw(required = "true"))]
    branches: Vec<BranchSpec>,
}

impl Opt {
    fn iterdir(&self) -> PathBuf {
        self.reldir.join(self.iteration.to_string())
    }
}

fn run() -> Fallible<()> {
    let opt = Opt::from_args();
    ensure!(opt.no_run, "vulnix integration is not implemented yet");
    let branches = Branches::init(&opt.branches)?;
    ensure!(branches.len() < 64, "Too many branches specified");
    let pkgs = transform(&opt.iterdir(), &branches)?;
    let dir = opt.iterdir();
    for (name, affected) in pkgs.iter() {
        let mut f = File::create(dir.join(format!("ticket.{}.md", name)))?;
        affected.write_ticket(&mut f, name, opt.iteration, &branches)?;
    }
    Ok(())
}

fn main() {
    if let Err(e) = run() {
        eprintln!("Error: {}", e);
        for cause in e.iter_causes() {
            eprintln!("Cause: {}", cause);
        }
        process::exit(1);
    }
}
