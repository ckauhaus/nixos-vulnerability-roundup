use colored::*;
use failure::{Context, Fallible, ResultExt};
use regex::Regex;
use serde::Serialize;
use std::fs::{create_dir, File};
use std::io::Write;
use std::ops::Deref;
use std::path::{Path, PathBuf};
use std::str::FromStr;
use subprocess::Exec;

#[derive(Debug, Fail)]
pub enum BranchError {
    #[fail(
        display = "Failed to recognize branch specification '{}'",
        _0
    )]
    InvalidSpec(String),
    #[fail(display = "Branch name '{}' is not unique", _0)]
    Duplicate(String),
}

/// NixOS release to scan. Note that the git rev/branch may have a different name than the release
/// name we publish.
#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct Branch {
    /// NixOS release name to publish in tickets
    pub name: String,
    /// git parseable revspec, usually a branch name
    pub rev: String,
}

impl Branch {
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_owned(),
            rev: name.to_owned(),
        }
    }

    pub fn checkout(&self, repo: &Path) -> Fallible<()> {
        println!(
            "{} {} @ {}",
            "* Checking out".green().bold(),
            self.name.green().bold(),
            self.rev[0..11].yellow()
        );
        let status = Exec::cmd("git")
            .args(&["checkout", "-q", &self.rev])
            .cwd(repo)
            .join()
            .context("Failed to execute 'git'")?;
        ensure!(status.success(), "Could not check out revision");
        Ok(())
    }

    /// Creates release derivation. Returns path to derivation file.
    pub fn instantiate(&self, repo: &Path) -> Fallible<PathBuf> {
        println!("{}", "* Instantiating...".green());
        let cmd = Exec::cmd("nix-instantiate")
            .args(&["--quiet", "-I", "nixpkgs=.", "nixos/release-combined.nix"])
            .env("GC_INITIAL_HEAP_SIZE", "4G")
            .cwd(repo);
        println!("{}", cmd.to_cmdline_lossy().purple());
        let cap = cmd
            .capture()
            .context("Failed to execute 'nix-instantiate'")?;
        ensure!(cap.success(), "Failed to instantiate derivation");
        if let Some(first) = cap.stdout_str().lines().nth(0) {
            ensure!(
                first.starts_with("/nix/store"),
                "nix-instantiate output does not start with /nix/store: {}",
                first
            );
            let drv = PathBuf::from(first.trim_end());
            println!("{}", drv.display());
            Ok(drv)
        } else {
            bail!("Output of nix-instantiate is empty")
        }
    }

    /// File name for vulnix JSON results
    pub fn fname(&self, dir: &Path) -> PathBuf {
        dir.join(format!("vulnix.{}.json", self.name))
    }

    /// Invokes `vulnix` on a derivation
    fn vulnix(&self, drv: PathBuf, opt: &::Opt) -> Result<Vec<VulnixRes<String>>, Context<String>> {
        println!("{}", "* Scanning...".green());
        let full_url = format!("{}/{}.toml", opt.whitelist_url, self.name);
        let full_wl = opt.whitelist_dir.join(format!("{}.toml", self.name));
        let cmd = Exec::cmd(&opt.vulnix)
            .args(&["-j", "-w", &full_url, "-W"])
            .args(&[full_wl, drv]);
        println!("{}", cmd.to_cmdline_lossy().purple());
        let rdr = cmd
            .stream_stdout()
            .with_context(|_| format!("Failed to execute '{}'", opt.vulnix.display()))?;
        serde_json::from_reader(rdr).context("Failed to parse vulnix JSON output".into())
    }

    /// Writes scan results into a JSON file for subsequent reference
    fn save<S: AsRef<str> + Serialize>(&self, scan: &[VulnixRes<S>], dir: &Path) -> Fallible<()> {
        let mut f = File::create(self.fname(dir))?;
        serde_json::to_writer(f.try_clone()?, &scan)?;
        writeln!(f).map_err(Into::into)
    }
}

lazy_static! {
    static ref BRANCHSPEC: Regex = Regex::new(r"^([^/=[:space:]]+)(=(\S+))?$").unwrap();
}

impl FromStr for Branch {
    type Err = BranchError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match BRANCHSPEC.captures(s) {
            Some(cap) => {
                let name = &cap[1];
                match cap.get(3) {
                    Some(rev) => Ok(Branch {
                        name: name.into(),
                        rev: rev.as_str().into(),
                    }),
                    None => Ok(Branch::new(name)),
                }
            }
            None => Err(BranchError::InvalidSpec(s.to_owned())),
        }
    }
}

/// vulnix scan result item. vulnix output consists of a Vec of these.
#[derive(Debug, Clone, Default, PartialEq, Serialize, Deserialize)]
pub struct VulnixRes<S: AsRef<str>> {
    pub name: S,
    pub pname: S,
    pub version: S,
    pub affected_by: Vec<S>,
}

#[derive(Default)]
pub struct Branches {
    specs: Vec<Branch>,
    repo: Option<PathBuf>,
}

impl Branches {
    /// List of branches without git repository. Used when loading previous scan results
    /// from directory.
    pub fn init(specs: &[Branch]) -> Result<Self, BranchError> {
        let b = Self {
            specs: specs.to_owned(),
            ..Default::default()
        };
        for (idx, elem) in specs.iter().enumerate() {
            if specs.iter().skip(idx + 1).any(|s| s.name == elem.name) {
                return Err(BranchError::Duplicate(elem.name.clone()));
            }
        }
        Ok(b)
    }

    /// List of branches with associated git repository. Used when scanning from source.
    pub fn with_repo(specs: &[Branch], repo: &Path) -> Fallible<Self> {
        let mut bs = Branches {
            repo: Some(repo.to_owned()),
            ..Branches::init(specs)?
        };
        for mut b in bs.specs.iter_mut() {
            let cap = Exec::cmd("git")
                .args(&["rev-parse", "-q", &b.rev])
                .cwd(repo)
                .capture()
                .context("Failed to execute 'git'")?;
            ensure!(
                cap.success(),
                format!(
                    "Failed to determine revision number for {} in '{}'",
                    b.rev,
                    repo.display()
                )
            );
            b.rev = cap.stdout_str().trim_end().to_owned();
        }
        Ok(bs)
    }

    /// Converts applicable bitmap into list of release names
    pub fn decode(&self, branchmap: u64) -> Vec<&str> {
        let mut names = Vec::with_capacity(self.specs.len());
        for (idx, elem) in self.iter().enumerate() {
            if branchmap & (1 << idx) > 0 {
                names.push(elem.name.as_ref())
            }
        }
        names
    }

    /// Reads previous scan results from a directory
    pub fn load(
        &self,
        dir: &Path,
    ) -> Result<Vec<Vec<VulnixRes<String>>>, failure::Context<String>> {
        println!(
            "{} {}",
            "* Loading scan results from".green(),
            dir.display().to_string().yellow()
        );
        self.iter()
            .map(|b| {
                let fname = b.fname(dir);
                File::open(&fname)
                    .with_context(|_| format!("Cannot open file '{}'", fname.display()))
                    .and_then(|f| {
                        serde_json::from_reader(f).with_context(|_| {
                            format!("Failed to parse JSON file '{}'", fname.display())
                        })
                    })
            }).collect()
    }

    /// Checks out all specified branches in turn, instantiates the release derivation and invokes
    /// vulnix on it.
    pub fn scan(&self, opt: &::Opt) -> Fallible<Vec<Vec<VulnixRes<String>>>> {
        let repo = self
            .repo
            .as_ref()
            .expect("Bug: attempted to scan unspecified repository");
        let mut res = Vec::new();
        let dir = opt.iterdir();
        create_dir(&dir).ok();
        for mut b in &self.specs {
            b.checkout(repo)?;
            let drv = b.instantiate(repo)?;
            let scan = b.vulnix(drv, opt)?;
            b.save(&scan, &dir)?;
            res.push(scan);
        }
        Ok(res)
    }
}

impl Deref for Branches {
    type Target = [Branch];

    fn deref(&self) -> &Self::Target {
        &self.specs
    }
}

// === Tests ===

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs::read_to_string;
    use tempdir::TempDir;
    use tests::create_branches;

    #[test]
    fn correct_branchspecs() {
        assert_eq!(
            Branch::from_str("nixos-18.09").unwrap(),
            Branch {
                name: "nixos-18.09".into(),
                rev: "nixos-18.09".into()
            }
        );
        assert_eq!(
            Branch::from_str("nixos-18.09=55f4cd48").unwrap(),
            Branch {
                name: "nixos-18.09".into(),
                rev: "55f4cd48".into()
            }
        );
        assert_eq!(
            Branch::from_str("nixos-18.09=origin/release-18.09").unwrap(),
            Branch {
                name: "nixos-18.09".into(),
                rev: "origin/release-18.09".into()
            }
        );
    }

    #[test]
    fn branchspec_invalid_chars() {
        assert!(Branch::from_str("nixos 18.09").is_err());
        assert!(Branch::from_str("origin/nixos-18.09").is_err());
    }

    #[test]
    fn branchspec_empty() {
        assert!(Branch::from_str("nixos=").is_err());
        assert!(Branch::from_str("=abcdefg").is_err());
    }

    #[test]
    fn no_duplicate_branch_names() {
        assert!(create_branches(&["a", "b"]).is_ok());
        assert!(create_branches(&["a", "b", "a"]).is_err());
    }

    #[test]
    fn decode_names() {
        let b = create_branches(&["a", "b", "c"]).unwrap();
        assert_eq!(b.decode(0b000), &[] as &[&str]);
        assert_eq!(b.decode(0b001), &["a"]);
        assert_eq!(b.decode(0b110), &["b", "c"]);
    }

    #[test]
    fn load_json() {
        let dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("fixtures/iterations/1");
        let branches = create_branches(&["nixos-18.03", "nixos-18.09", "nixos-unstable"]).unwrap();
        let res = branches.load(&dir).unwrap();
        assert_eq!(res.len(), 3);
        assert_eq!(res[0].len(), 2);
        assert_eq!(res[1].len(), 4);
        assert_eq!(res[2].len(), 3);
    }

    #[test]
    fn write_json() {
        let dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("fixtures/iterations/1");
        let branches = create_branches(&["nixos-18.09"]).unwrap();
        let res = branches.load(&dir).unwrap();
        let td = TempDir::new("test_write_json").unwrap();
        branches[0].save(&res[0], td.path()).unwrap();
        let reread: Vec<VulnixRes<String>> =
            serde_json::from_reader(File::open(td.path().join("vulnix.nixos-18.09.json")).unwrap())
                .unwrap();
        assert_eq!(res[0], reread);
    }

    /// Little shell script which unconditionally writes the contents of
    /// fixtures/iterations/1/vulnix.nixos-18.09.json to stdout
    fn fake_vulnix() -> PathBuf {
        Path::new(env!("CARGO_MANIFEST_DIR")).join("fixtures/fake_vulnix")
    }

    #[test]
    fn run_vulnix() {
        let mut opt = ::Opt::default();
        opt.vulnix = fake_vulnix();
        opt.reldir = Path::new(env!("CARGO_MANIFEST_DIR")).join("fixtures/iterations");
        opt.iteration = 1;
        let b = Branch::new("nixos-18.09.json");
        let res = b.vulnix(PathBuf::new(), &opt).unwrap();
        let exp: Vec<VulnixRes<String>> = serde_json::from_str(
            &read_to_string(opt.iterdir().join("vulnix.nixos-18.09.json")).unwrap(),
        ).unwrap();
        assert_eq!(res, exp);
    }
}
