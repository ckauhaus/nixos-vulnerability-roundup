use super::Opt;
use crate::advisory::Advisory;
use crate::package::Package;
use colored::*;
use git2::Repository;
use regex::Regex;
use smallstr::SmallString;
use snafu::{ensure, ResultExt, Snafu};
use std::collections::HashMap;
use std::fmt;
use std::fs::{self, File};
use std::io;
use std::ops::Deref;
use std::path::{Path, PathBuf};
use std::str::FromStr;
use subprocess::{Exec, PopenError};

#[derive(Debug, Snafu)]
pub enum Error {
    #[snafu(display("Cannot recognize branch specification '{}'", spec))]
    InvalidBranchSpec { spec: String },
    #[snafu(display("Branch name '{}' is not unique", name))]
    DuplicateBranch { name: String },
    #[snafu(display("Cannot execute git"))]
    GitError { source: PopenError },
    #[snafu(display("Cannot check out revision '{}'", rev))]
    CheckoutError { rev: String },
    #[snafu(display("Cannot execute nix-instantiate"))]
    NixInstantiateError { source: PopenError },
    #[snafu(display("nix-instantiate output does not start with /nix/store: {}", prefix))]
    StorePrefixError { prefix: String },
    #[snafu(display("Cannot instantiate derivation"))]
    InstantiateError,
    #[snafu(display("Output of nix-instantiate is empty!"))]
    EmptyInstantiateError,
    #[snafu(display("Cannot execute '{}'", vulnix.display()))]
    VulnixExecError { vulnix: PathBuf, source: PopenError },
    #[snafu(display("Cannot parse vulnix JSON output"))]
    JSONParseError { source: serde_json::error::Error },
    #[snafu(display("Cannot create vulnix JSON"))]
    JSONSerError { source: serde_json::error::Error },
    #[snafu(display("Cannot save vulnix results to '{}'", fname.display()))]
    SaveError { fname: PathBuf, source: io::Error },
    #[snafu(display("git error while resolving rev '{}'", rev))]
    RevError { rev: String, source: git2::Error },
    #[snafu(display("Cannot open git repository"))]
    RepositoryError { source: git2::Error },
    #[snafu(display("Cannot open saved vulnix results '{}'", fname.display()))]
    OpenError { fname: PathBuf, source: io::Error },
}

type Result<T, E = Error> = std::result::Result<T, E>;

/// vulnix scan result item. vulnix output consists of a Vec of these.
#[derive(Debug, Clone, Default, PartialEq, Serialize, Deserialize)]
pub struct VulnixRes {
    #[serde(rename = "name")]
    pub pkg: Package,
    pub affected_by: Vec<Advisory>,
}

pub type ScanByBranch = HashMap<Branch, Vec<VulnixRes>>;

/// NixOS release to scan. Note that the git rev/branch may have a different name than the release
/// name we publish.
#[derive(Debug, Clone, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub struct Branch {
    /// NixOS release name to publish in tickets
    pub name: SmallString<[u8; 16]>,
    /// git parseable revspec, usually a branch name
    pub rev: SmallString<[u8; 16]>,
}

impl Branch {
    pub fn new(name: &str) -> Self {
        Self {
            name: SmallString::from_str(name),
            rev: SmallString::from_str(name),
        }
    }

    pub fn checkout(&self, repo: &Path) -> Result<()> {
        println!(
            "{} {} @ {}",
            "* Checking out".green().bold(),
            self.name.green().bold(),
            self.rev[0..11].yellow()
        );
        let status = Exec::cmd("git")
            .args(&["checkout", "-q", &self.rev])
            .cwd(repo)
            .join()
            .context(GitError {})?;
        ensure!(
            status.success(),
            CheckoutError {
                rev: self.rev.to_string()
            }
        );
        Ok(())
    }

    /// Creates release derivation. Returns path to derivation file.
    pub fn instantiate(&self, repo: &Path) -> Result<PathBuf> {
        println!("{}", "* Instantiating...".green());
        let cmd = Exec::cmd("nix-instantiate")
            .args(&["--quiet", "-I", "nixpkgs=.", "nixos/release-combined.nix"])
            .env("GC_INITIAL_HEAP_SIZE", "4G")
            .cwd(repo);
        println!("{}", cmd.to_cmdline_lossy().purple());
        let cap = cmd.capture().context(NixInstantiateError {})?;
        ensure!(cap.success(), InstantiateError);
        if let Some(first) = cap.stdout_str().lines().nth(0) {
            ensure!(
                first.starts_with("/nix/store"),
                StorePrefixError { prefix: first }
            );
            let drv = PathBuf::from(first.trim_end());
            println!("{}", drv.display());
            Ok(drv)
        } else {
            Err(Error::EmptyInstantiateError)
        }
    }

    /// Full path to JSON file containing vulnix scan results
    pub fn vulnix_json(&self, dir: &Path) -> PathBuf {
        dir.join(format!("vulnix.{}.json", self.name.as_str()))
    }

    /// Invokes `vulnix` on a derivation
    ///
    /// vulnix' output is saved to a JSON file iff parsing passed.
    fn vulnix(&self, drv: PathBuf, opt: &Opt) -> Result<Vec<VulnixRes>> {
        println!("{}", "* Scanning...".green());
        let full_url = format!("{}/{}.toml", opt.whitelist_url, self.name.as_str());
        let full_wl = opt
            .whitelist_dir
            .join(format!("{}.toml", self.name.as_str()));
        let cmd = Exec::cmd(&opt.vulnix)
            .args(&["-j", "-w", &full_url, "-W"])
            .args(&[full_wl, drv]);
        println!("{}", cmd.to_cmdline_lossy().purple());
        let mut rdr = cmd.stream_stdout().context(VulnixExecError {
            vulnix: &opt.vulnix,
        })?;
        let mut stdout = String::with_capacity(4096);
        rdr.read_to_string(&mut stdout).expect("read from stdout");
        let res = serde_json::from_str(&stdout).context(JSONParseError);
        // save for future reference
        let iterdir = opt.iterdir();
        let fname = self.vulnix_json(&iterdir);
        fs::create_dir_all(&iterdir)
            .and_then(|_| fs::write(&fname, &stdout))
            .context(SaveError { fname })?;
        res
    }
}

lazy_static! {
    static ref BRANCHSPEC: Regex = Regex::new(r"^([^/=[:space:]]+)(=(\S+))?$").unwrap();
}

impl FromStr for Branch {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match BRANCHSPEC.captures(s) {
            Some(cap) => {
                let name = &cap[1];
                match cap.get(3) {
                    Some(rev) => Ok(Branch {
                        name: name.into(),
                        rev: rev.as_str().into(),
                    }),
                    None => Ok(Branch::new(name)),
                }
            }
            None => (InvalidBranchSpec { spec: s }).fail(),
        }
    }
}

impl fmt::Display for Branch {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        write!(fmt, "{}", self.name.as_str())
    }
}

fn resolve_rev(rev: &str, repo: &Repository) -> Result<String> {
    Ok(repo
        .revparse_single(rev)
        .context(RevError { rev })?
        .id()
        .to_string())
}

#[derive(Default, Clone)]
pub struct Branches {
    specs: Vec<Branch>,
    repo: Option<PathBuf>,
}

impl Branches {
    /// List of branches without git repository. Used when loading previous scan results
    /// from directory.
    pub fn init(specs: &[Branch]) -> Result<Self, Error> {
        let b = Self {
            specs: specs.to_owned(),
            ..Default::default()
        };
        for (idx, elem) in specs.iter().enumerate() {
            if specs.iter().skip(idx + 1).any(|s| s.name == elem.name) {
                return (DuplicateBranch {
                    name: elem.name.as_str(),
                })
                .fail();
            }
        }
        Ok(b)
    }

    /// List of branches with associated git repository. Used when scanning from source.
    pub fn with_repo(specs: &[Branch], repo: &Path) -> Result<Self> {
        let mut bs = Branches {
            repo: Some(repo.to_owned()),
            ..Branches::init(specs)?
        };
        let repo = Repository::open(repo).context(RepositoryError)?;
        for mut b in bs.specs.iter_mut() {
            b.rev = SmallString::from(resolve_rev(b.rev.as_str(), &repo)?);
        }
        Ok(bs)
    }

    /// Reads previous scan results from a directory
    pub fn load(&self, dir: &Path) -> Result<ScanByBranch> {
        println!(
            "{} {}",
            "* Loading scan results from".green(),
            dir.display().to_string().yellow()
        );
        let mut sbb = ScanByBranch::new();
        for branch in self.iter() {
            let fname = branch.vulnix_json(dir);
            let f = File::open(&fname).context(OpenError { fname })?;
            sbb.insert(
                branch.clone(),
                serde_json::from_reader(f).context(JSONParseError)?,
            );
        }
        Ok(sbb)
    }

    /// Checks out all specified branches in turn, instantiates the release derivation and invokes
    /// vulnix on it.
    pub fn scan(&self, opt: &Opt) -> Result<ScanByBranch> {
        let repo = self
            .repo
            .as_ref()
            .expect("Bug: attempted to scan unspecified repository");
        let dir = opt.iterdir();
        fs::create_dir(&dir).ok();
        let mut sbb = ScanByBranch::new();
        for branch in self.iter() {
            branch.checkout(repo)?;
            let drv = branch.instantiate(repo)?;
            let scan = branch.vulnix(drv, opt)?;
            sbb.insert(branch.clone(), scan);
        }
        Ok(sbb)
    }
}

impl Deref for Branches {
    type Target = [Branch];

    fn deref(&self) -> &Self::Target {
        &self.specs
    }
}

// === Tests ===

#[cfg(test)]
mod test {
    use super::*;
    use crate::tests::{br, create_branches};
    use libflate::gzip;
    use std::error::Error;
    use std::fs::read_to_string;
    use tar::Archive;
    use tempdir::TempDir;

    #[test]
    fn correct_branchspecs() {
        assert_eq!(
            Branch::from_str("nixos-18.09").unwrap(),
            Branch {
                name: "nixos-18.09".into(),
                rev: "nixos-18.09".into()
            }
        );
        assert_eq!(
            Branch::from_str("nixos-18.09=55f4cd48").unwrap(),
            Branch {
                name: "nixos-18.09".into(),
                rev: "55f4cd48".into()
            }
        );
        assert_eq!(
            Branch::from_str("nixos-18.09=origin/release-18.09").unwrap(),
            Branch {
                name: "nixos-18.09".into(),
                rev: "origin/release-18.09".into()
            }
        );
    }

    #[test]
    fn branchspec_invalid_chars() {
        assert!(Branch::from_str("nixos 18.09").is_err());
        assert!(Branch::from_str("origin/nixos-18.09").is_err());
    }

    #[test]
    fn branchspec_empty() {
        assert!(Branch::from_str("nixos=").is_err());
        assert!(Branch::from_str("=abcdefg").is_err());
    }

    #[test]
    fn no_duplicate_branch_names() {
        assert!(Branches::init(&[br("a"), br("b")]).is_ok());
        assert!(Branches::init(&[br("a"), br("b"), br("a")]).is_err());
    }

    #[test]
    fn load_json() {
        let dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("fixtures/iterations/1");
        let branches = create_branches(&["nixos-18.03", "nixos-18.09", "nixos-unstable"]);
        let res = branches.load(&dir).unwrap();
        assert_eq!(res.len(), 3);
        assert_eq!(res[&br("nixos-18.03")].len(), 2);
        assert_eq!(res[&br("nixos-18.09")].len(), 4);
        assert_eq!(res[&br("nixos-unstable")].len(), 3);
    }

    /// Little shell script which unconditionally writes the contents of
    /// fixtures/iterations/1/vulnix.nixos-18.09.json to stdout
    fn fake_vulnix() -> PathBuf {
        Path::new(env!("CARGO_MANIFEST_DIR")).join("fixtures/fake_vulnix")
    }

    #[test]
    fn run_vulnix() {
        let td = TempDir::new("test_write_json").unwrap();
        let mut opt = Opt::default();
        opt.vulnix = fake_vulnix();
        opt.basedir = td.path().to_path_buf();
        opt.iteration = 1;
        let orig_json = Path::new(env!("CARGO_MANIFEST_DIR"))
            .join("fixtures/iterations/1/vulnix.nixos-18.09.json");
        let exp: Vec<VulnixRes> =
            serde_json::from_str(&read_to_string(&orig_json).unwrap()).unwrap();
        let res = br("nixos-18.09")
            .vulnix(PathBuf::from("result"), &opt)
            .unwrap();
        assert_eq!(res, exp);
        // see if vulnix() saved original output
        assert_eq!(
            read_to_string(orig_json).expect("read original vulnix json"),
            read_to_string(td.path().join("1/vulnix.nixos-18.09.json"))
                .expect("cannot read saved vulnix results (file exists?)")
        );
    }

    #[test]
    fn resolve_branches() -> Result<(), Box<dyn Error>> {
        let tmp = TempDir::new("test_resolve_branches")?;
        let tarball = Path::new(env!("CARGO_MANIFEST_DIR")).join("fixtures/repo.tar.gz");
        Archive::new(gzip::Decoder::new(File::open(tarball)?)?).unpack(&tmp)?;
        let repo = Repository::open(&tmp.path().join("repo"))?;
        assert_eq!(
            "117a41dff30a62f2e4ef68c7e237ed497150b6dd",
            resolve_rev("117a41d", &repo)?
        );
        assert_eq!(
            "8dfec1442bf901fbfc09572ae0ea58d5ce8b4462",
            resolve_rev("master", &repo)?
        );
        assert_eq!(
            "12fe4b957c99f41b0885021599b445ac4a02623a",
            resolve_rev("b1", &repo)?
        );
        Ok(())
    }
}
