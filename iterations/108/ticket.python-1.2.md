# Vulnerability roundup 108: python-1.2: 18 advisories [9.8]

[search](https://search.nix.gsc.io/?q=python&i=fosho&repos=NixOS-nixpkgs), [files](https://github.com/NixOS/nixpkgs/search?utf8=%E2%9C%93&q=python+in%3Apath&type=Code)

* [ ] [CVE-2016-5636](https://nvd.nist.gov/vuln/detail/CVE-2016-5636) CVSSv3=9.8 (nixos-unstable)
* [ ] [CVE-2017-1000158](https://nvd.nist.gov/vuln/detail/CVE-2017-1000158) CVSSv3=9.8 (nixos-unstable)
* [ ] [CVE-2017-17522](https://nvd.nist.gov/vuln/detail/CVE-2017-17522) CVSSv3=8.8 (nixos-unstable)
* [ ] [CVE-2019-13404](https://nvd.nist.gov/vuln/detail/CVE-2019-13404) CVSSv3=7.8 (nixos-unstable)
* [ ] [CVE-2018-1060](https://nvd.nist.gov/vuln/detail/CVE-2018-1060) CVSSv3=7.5 (nixos-unstable)
* [ ] [CVE-2018-1061](https://nvd.nist.gov/vuln/detail/CVE-2018-1061) CVSSv3=7.5 (nixos-unstable)
* [ ] [CVE-2019-5010](https://nvd.nist.gov/vuln/detail/CVE-2019-5010) CVSSv3=7.5 (nixos-unstable)
* [ ] [CVE-2019-9674](https://nvd.nist.gov/vuln/detail/CVE-2019-9674) CVSSv3=7.5 (nixos-unstable)
* [ ] [CVE-2019-16056](https://nvd.nist.gov/vuln/detail/CVE-2019-16056) CVSSv3=7.5 (nixos-unstable)
* [ ] [CVE-2019-20907](https://nvd.nist.gov/vuln/detail/CVE-2019-20907) CVSSv3=7.5 (nixos-unstable)
* [ ] [CVE-2016-0772](https://nvd.nist.gov/vuln/detail/CVE-2016-0772) CVSSv3=6.5 (nixos-unstable)
* [ ] [CVE-2017-18207](https://nvd.nist.gov/vuln/detail/CVE-2017-18207) CVSSv3=6.5 (nixos-unstable)
* [ ] [CVE-2016-5699](https://nvd.nist.gov/vuln/detail/CVE-2016-5699) CVSSv3=6.1 (nixos-unstable)
* [ ] [CVE-2016-1000110](https://nvd.nist.gov/vuln/detail/CVE-2016-1000110) CVSSv3=6.1 (nixos-unstable)
* [ ] [CVE-2019-16935](https://nvd.nist.gov/vuln/detail/CVE-2019-16935) CVSSv3=6.1 (nixos-unstable)
* [ ] [CVE-2021-23336](https://nvd.nist.gov/vuln/detail/CVE-2021-23336) CVSSv3=5.9 (nixos-unstable)
* [ ] [CVE-2021-3426](https://nvd.nist.gov/vuln/detail/CVE-2021-3426) CVSSv3=5.7 (nixos-unstable)
* [ ] [CVE-2018-1000030](https://nvd.nist.gov/vuln/detail/CVE-2018-1000030) CVSSv3=3.6 (nixos-unstable)

## CVE details

### CVE-2016-5636

Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.

### CVE-2017-1000158

CPython (aka Python) up to 2.7.13 is vulnerable to an integer overflow in the PyString_DecodeEscape function in stringobject.c, resulting in heap-based buffer overflow (and possible arbitrary code execution)

### CVE-2017-17522

** DISPUTED ** Lib/webbrowser.py in Python through 3.6.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL. NOTE: a software maintainer indicates that exploitation is impossible because the code relies on subprocess.Popen and the default shell=False setting.

### CVE-2019-13404

** DISPUTED ** The MSI installer for Python through 2.7.16 on Windows defaults to the C:\Python27 directory, which makes it easier for local users to deploy Trojan horse code. (This also affects old 3.x releases before 3.5.) NOTE: the vendor's position is that it is the user's responsibility to ensure C:\Python27 access control or choose a different directory, because backwards compatibility requires that C:\Python27 remain the default for 2.7.x.

### CVE-2018-1060

python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in pop3lib's apop() method. An attacker could use this flaw to cause denial of service.

### CVE-2018-1061

python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in the difflib.IS_LINE_JUNK method.  An attacker could use this flaw to cause denial of service.

### CVE-2019-5010

An exploitable denial-of-service vulnerability exists in the X509 certificate parser of Python.org Python 2.7.11 / 3.6.6. A specially crafted X509 certificate can cause a NULL pointer dereference, resulting in a denial of service. An attacker can initiate or accept TLS connections using crafted certificates to trigger this vulnerability.

### CVE-2019-9674

Lib/zipfile.py in Python through 3.7.2 allows remote attackers to cause a denial of service (resource consumption) via a ZIP bomb.

### CVE-2019-16056

An issue was discovered in Python through 2.7.16, 3.x through 3.5.7, 3.6.x through 3.6.9, and 3.7.x through 3.7.4. The email module wrongly parses email addresses that contain multiple @ characters. An application that uses the email module and implements some kind of checks on the From/To headers of a message could be tricked into accepting an email address that should be denied. An attack may be the same as in CVE-2019-11340; however, this CVE applies to Python more generally.

### CVE-2019-20907

In Lib/tarfile.py in Python through 3.8.3, an attacker is able to craft a TAR archive leading to an infinite loop when opened by tarfile.open, because _proc_pax lacks header validation.

### CVE-2016-0772

The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a "StartTLS stripping attack."

### CVE-2017-18207

** DISPUTED ** The Wave_read._read_fmt_chunk function in Lib/wave.py in Python through 3.6.4 does not ensure a nonzero channel value, which allows attackers to cause a denial of service (divide-by-zero and exception) via a crafted wav format audio file. NOTE: the vendor disputes this issue because Python applications "need to be prepared to handle a wide variety of exceptions."

### CVE-2016-5699

CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.

### CVE-2016-1000110

The CGIHandler class in Python before 2.7.12 does not protect against the HTTP_PROXY variable name clash in a CGI script, which could allow a remote attacker to redirect HTTP requests.

### CVE-2019-16935

The documentation XML-RPC server in Python through 2.7.16, 3.x through 3.6.9, and 3.7.x through 3.7.4 has XSS via the server_title field. This occurs in Lib/DocXMLRPCServer.py in Python 2.x, and in Lib/xmlrpc/server.py in Python 3.x. If set_server_title is called with untrusted input, arbitrary JavaScript can be delivered to clients that visit the http URL for this server.

### CVE-2021-23336

The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.

### CVE-2021-3426

There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.

### CVE-2018-1000030

Python 2.7.14 is vulnerable to a Heap-Buffer-Overflow as well as a Heap-Use-After-Free. Python versions prior to 2.7.14 may also be vulnerable and it appears that Python 2.7.17 and prior may also be vulnerable however this has not been confirmed. The vulnerability lies when multiply threads are handling large amounts of data. In both cases there is essentially a race condition that occurs. For the Heap-Buffer-Overflow, Thread 2 is creating the size for a buffer, but Thread1 is already writing to the buffer without knowing how much to write. So when a large amount of data is being processed, it is very easy to cause memory corruption using a Heap-Buffer-Overflow. As for the Use-After-Free, Thread3->Malloc->Thread1->Free's->Thread2-Re-uses-Free'd Memory. The PSRT has stated that this is not a security vulnerability due to the fact that the attacker must be able to run code, however in some situations, such as function as a service, this vulnerability can potentially be used by an attacker to violate a trust boundary, as such the DWF feels this issue deserves a CVE.

-----
Scanned versions: nixos-unstable: 942eb9a335b.

Cc @ehmry

